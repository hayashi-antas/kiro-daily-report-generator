以下は、**同一仕様書で「Kiro（仕様駆動）」と「Gemini（一括生成寄り）」を回したときの差**が一目で分かるようにまとめた比較表です。

## Kiro vs Gemini 比較表（同一仕様書を入力した前提）

| 観点 | **Kiro（Spec-Driven Development）** | **Gemini（Code Assist / Gemini系の一括生成体験）** |
| --- | --- | --- |
| 基本思想 | **仕様→設計→実装**の“工程”を作り、順番に進める（ワークフロー前提） | **対話から即アウトプット**（生成・修正・説明・デバッグ等を都度依頼） |
| 進め方（体験） | ステップが分かれ、**各フェーズに意思決定ポイント**がある＝ユーザー承認で前進しやすい | **一発で成果物が出やすい**（途中の根拠・設計ログは自分で引き出す必要が出がち） |
| 品質コントロール | 「要求→設計→タスク化」の形に落ちるので、**レビュー観点が固定されやすい**（要求の漏れ・矛盾を早めに潰せる） | 生成は速いが、**品質は“後追いで差分レビュー”になりやすい**（仕様への適合チェックを自分で設計する必要） |
| AIの制御（暴走しにくさ） | 仕様を軸に作業が分割されるため、**スコープ逸脱が起きた時に戻しやすい**（実体験に基づく所感） | 早い反面、**前提がずれたまま走る**ことがある（プロンプトで都度リセット／制約強化が必要） |
| トレーサビリティ（なぜそうなったか） | 各ステップがドキュメント化されやすく、**「どの要求がどの実装に効いたか」**を追いやすい | 生成物は残るが、**工程の記録は運用次第**（会話ログ・設計メモ・判断ログを自作しがち） |
| プロトタイピング速度 | “設計の時間”を確保する分、**初速はやや遅く見える**（ただし手戻り削減が狙い） | **初速が速い**。とりあえず動くもの・画面・雰囲気を出すのが得意 |
| 変更への強さ | 仕様に戻って調整→再生成の形が取りやすく、**変更理由と影響範囲**が整理しやすい | 変更依頼は柔軟だが、**全体整合（設計・テスト・ドキュメント）を揃える運用が必要** |
| チーム／ガバナンス | 工程と成果物（仕様・設計・タスク）が揃うので、**レビュー・合意形成に向く** | 個人の試作〜小規模には強いが、**合意形成は別途ドキュメント整備が要る** |
| 向いてる用途 | 本番品質／仕様の厳密さ／関係者が多い開発／「作る前に決めたい」 | PoC／UIプロトタイプ／不確実性が高い探索／「まず形にしたい」 |

---

## 使い分けの結論

- **Kiroは「品質を“工程で作る”」**  
  段階承認で進むため、AIの挙動を制御しやすく、仕様の漏れや矛盾を早い段階で潰しやすい。

- **Geminiは「速度で“仮説を増やす”」**  
  一発目のプロトタイプが非常に速い。その代わり、途中経過（設計意図・判断ログ）は意識的に引き出し、記録として残す設計が必要になる。


## 実務での“混ぜ方”テンプレ

* **探索期（0→1）**：Geminiで「画面・APIの叩き台」「未知の論点洗い出し」を高速に作る
* **収束期（1→10）**：Kiroで「要求の確定」「設計」「タスク分割」「レビュー観点固定」をして品質を上げる
* **共通のコツ**：どちらでも、最終的には *仕様→テスト→実装* の整合を人間がチェックする（AI生成の形が違うだけで、検証責任は同じ）
